@startuml
digraph G {
node[shape=Mrecord, style=rounded, shadow_offset=7, shadow_blur=5];Model;View;Controller
    View -> Model
    Controller -> View
    Controller -> Model
}

note left
 You can use images
<img:../mvc.png>
end note
@enduml

@startuml
skinparam dpi 300
scale 1200*600
object "inbound message" as m1
object "XML Splitter" as s1

m1 : <img:../mvc.png>
s1 : <img:SplitterIcon.gif>
m2 : <img:MessageIcon.gif>

m1 -> s1
s1 -> m2

@enduml

@startdot
digraph G {
size="7.5,10";
node  [style="rounded,filled,bold",center=true,rotate=90, shape=box, fixedsize=true, width=1.3, fontname="Arial",width=1.25];
Model -> View[style=dotted,arrowsize=1.5, arrowhead=empty][label="Change notification"]
Model -> View[label="State query",minlen=1.5][dir=back];
Model -> Controller[label="State c.M5Ihange", splines=ortho, nodesep=1,labelangle=3.14][dir=back];
View -> Controller[label="View selection",concentrate=true][dir=back];
View -> Controller[style=dotted,arrowsize=1.5, arrowhead=empty][label="\n\nUser actions",labeljust="r"];
{rank=same;View Controller}
/*labelloc=b,labeljust=r,decorate=true,*/
}

@enddot

@startuml
[AA] <<static lib>>
[BB] <<shared lib>>
[CC] <<static lib>>

node node1
node node2 <<shared node>>
database Production

skinparam component {
    backgroundColor<<static lib>> DarkKhaki
    backgroundColor<<shared lib>> Green
}

skinparam node {
	borderColor Green
	backgroundColor Yellow
	backgroundColor<<shared node>> Magenta
}
skinparam databaseBackgroundColor Aqua

@enduml

@startdot
digraph G {
size="7.5,10";
node  [style="rounded,filled,bold",center=true,rotate=90, shape=box, fixedsize=true, width=1.3, fontname="Arial",width=1.25];
Model -> View[style=dotted,arrowsize=1.5, arrowhead=empty][label="Change notification"]
Model -> View[label="State query",minlen=1.5][dir=back];
Model -> Controller[label="State change", splines=ortho, nodesep=1,labelangle=3.14][dir=back];
View -> Controller[label="View selection",concentrate=true][dir=back];
View -> Controller[style=dotted,arrowsize=1.5, arrowhead=empty][label="\n\nUser actions",labeljust="r"];
{rank=same;View Controller}
/*labelloc=b,labeljust=r,decorate=true,*/
}
@enddot

@startuml
skinparam lifelineStrategy solid
skinparam handwritten false
skinparam monochrome true
skinparam packageStyle rect
skinparam defaultFontName FG Virgil
skinparam shadowing true
skinparam classBorderThickness .5
skinparam usecaseBorderThickness .5
skinparam titleBorderRoundCorner 15
skinparam titleBorderThickness 2
skinparam rectangleBorderThickness 0.5

skinparam classBorderThickness<<stereo>> 5
skinparam packageBorderThickness<<stereo>> 1.5
skinparam packageBorderThickness 0.5
skinparam classFontColor red
skinparam classFontSize 10
skinparam classFontName Courier

participant "__Connection Factories__" as connectionFactories
participant "__Connections__" as Connections
participant "__Session__" as Session
participant "__Message Producer__" as messageProducer
participant "__Message Consumer__" as messageConsumer
participant "__Temporary Destination__" as temporaryDestination
participant "__Broker__" as Broker


/' This is how you can
span multiple lines
of comments
'/
hide footbox
title Connection Factories

connectionFactories -> Connections : createConnections()
activate Connections
Connections -> Session : createSession()
deactivate Connections
activate Session

Session -> messageProducer : CreateProducer()
activate messageProducer
Session -> messageProducer : CreateMessage()
deactivate Session


deactivate messageProducer
Session -> temporaryDestination : createTemporaryQueue() or createTemporaryTopic()
activate temporaryDestination
deactivate temporaryDestination
Session -> messageConsumer : CreateConsumer()
activate messageConsumer
deactivate messageConsumer

Connections -> Connections: start()
activate Connections
deactivate Connections
messageProducer -> Broker : send()
activate Broker
Broker -> temporaryDestination: send()
deactivate Broker
activate temporaryDestination
deactivate temporaryDestination



@enduml

@startdot
graph cube {
forcelabels=true

node [shape=point, color=red, fontcolor=red]

1[xlabel="1"]
2[xlabel="2"]
3[xlabel="3"]
4[xlabel="4"]
5[xlabel="5"]
6[xlabel="6"]
7[xlabel="7"]
8[xlabel="8"]

1--2[label="1"]
2--3[label="2"]
3--4[label="3"]
4--1[label="4"]
5--6[label="5"]
6--7[label="6"]
7--8[label="7"]
8--5[label="8"]
1--5[label="9"]
2--6[label="10"]
3--7[label="11"]
4--8[label="12"]
}
@enddot
@startdot
digraph G {
layers = "spec:design:code:debug:ship";
node90 [layer = "code"];
node91 [layer = "design:debug"];
node92 [layer = "all:code"];
node93 [layer = "spec:code,ship"];
node90 -> node91 [layer = "all"];

}
@enddot
@startdot
digraph G {
ranksep=.75; size = "7.5,7.5";
{
node [shape=plaintext, fontsize=16];
/* the time-line graph */
past -> 1978 -> 1980 -> 1982 -> 1983 -> 1985 -> 1986 ->
1987 -> 1988 -> 1989 -> 1990 -> "future";
/* ancestor programs */
"Bourne sh"; "make"; "SCCS"; "yacc"; "cron"; "Reiser cpp";
"Cshell"; "emacs"; "build"; "vi"; "<curses>"; "RCS"; "C*";
}
{ rank = same;
"Software IS"; "Configuration Mgt"; "Architecture & Libraries";
"Process";
};
node [shape=box];
{ rank = same; "past"; "SCCS"; "make"; "Bourne sh"; "yacc"; "cron"; }
{ rank = same; 1978; "Reiser cpp"; "Cshell"; }
{ rank = same; 1980; "build"; "emacs"; "vi"; }
{ rank = same; 1982; "RCS"; "<curses>"; "IMX"; "SYNED"; }
{ rank = same; 1983; "ksh"; "IFS"; "TTU"; }
{ rank = same; 1985; "nmake"; "Peggy"; }
{ rank = same; 1986; "C*"; "ncpp"; "ksh-i"; "<curses-i>"; "PG2"; }
{ rank = same; 1987; "Ansi cpp"; "nmake 2.0"; "3D File System"; "fdelta";
"DAG"; "CSAS";}
{ rank = same; 1988; "CIA"; "SBCS"; "ksh-88"; "PEGASUS/PML"; "PAX";
"backtalk"; }
{ rank = same; 1989; "CIA++"; "APP"; "SHIP"; "DataShare"; "ryacc";
"Mosaic"; }
{ rank = same; 1990; "libft"; "CoShell"; "DIA"; "IFS-i"; "kyacc"; "sfio";
"yeast"; "ML-X"; "DOT"; }
{ rank = same; "future"; "Adv. Software Technology"; }
"PEGASUS/PML" -> "ML-X";
"SCCS" -> "nmake";
"SCCS" -> "3D File System";
"SCCS" -> "RCS";
"make" -> "nmake";
"make" -> "build";

}
@enddot

@startdot
digraph G {
 abc [shape=none, margin=0, label=<
 <TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0" CELLPADDING="4">
 <TR><TD ROWSPAN="3"><FONT COLOR="red">hello</FONT><BR/>world</TD>
 <TD COLSPAN="3">b</TD>
 <TD ROWSPAN="3" BGCOLOR="lightgrey">g</TD>
 <TD ROWSPAN="3">h</TD>
 </TR>
 <TR><TD>c</TD>
 <TD PORT="here">d</TD>
 <TD>e</TD>
 </TR>
 <TR><TD COLSPAN="3">f</TD>
 </TR>
 </TABLE>>];
}
@enddot
@startdot
graph G {
 splines = true;
    node1 [shape=circle, style = filled, width=.15, label = "1", type = "rt"];
    node2 [shape=circle, style = filled, width=.15, label = "2", type = "re"];
    node3 [shape=circle, style = filled, width=.15, label = "3", type = "node"];
    node4 [shape=circle, style = filled, width=.15, label = "4", type = "rt"];
    node5 [shape=circle, style = filled, width=.15, label = "5", type = "node"];
    node6 [shape=doublecircle, style = filled, width=.15, label = "6", type = "re"];

    RouteEntry0 [shape = box, style = filled, label = RouteEntry]
    RouteEntry0 -- node1 [taillabel = 0, labelangle=-35, labeldistance=1];
    RouteEntry0 -- node2 [taillabel = 1, labelangle=-35, labeldistance=1];

    RouteAddress0 [shape = box, style = filled, label = RouteAddress]
    RouteAddress0 -- node2 [taillabel = 0, labelangle=-35, labeldistance=1];
    RouteAddress0 -- node5 [taillabel = 1, labelangle=-35, labeldistance=1];

    RouteNextHopAddress [shape = box, style = filled]
    RouteNextHopAddress -- node2 [taillabel = 0, labelangle=-35, labeldistance=1];
    RouteNextHopAddress -- node3 [taillabel = 1, labelangle=-35, labeldistance=1];

    RouteTable [shape = box, style = filled]
    RouteTable -- node3 [taillabel = 0, labelangle=-35, labeldistance=1];
    RouteTable -- node4 [taillabel = 1, labelangle=-35, labeldistance=1];

    RouteEntry1 [shape = doubleoctagon, style = filled, label = RouteEntry]
    RouteEntry1 -- node4 [taillabel = 0, labelangle=-35, labeldistance=1];
    RouteEntry1 -- node6 [taillabel = 1, labelangle=-35, labeldistance=1];

    RouteAddress1 [shape = doubleoctagon, style = filled, label = RouteAddress]
    RouteAddress1 -- node6 [taillabel = 0, labelangle=-35, labeldistance=1];
    RouteAddress1 -- node5 [taillabel = 1, labelangle=-35, labeldistance=1];

    label = ""
    fontsize=20;
}
@enddot
@startdot
digraph G {

node [color=black,shape=circle]

I [label="R"]

subgraph infoset1
{
   label="whatever"
   rank="same"
   1 [label="C"]
   2 [label="C"]
}

I -> 1 [headlabel="War", labeldistance=3, labelangle=40]
I -> 2 [headlabel="Peace", labeldistance=3, labelangle=-40]
1 -> 2 [style=dashed, dir=none]

subgraph info21
{
    rank="same"
    3 [label="(2,2)", rank=sink, shape="plaintext"]
    4 [label="(5,1)", rank=sink, shape="plaintext"]
    5 [label="(1,5)", rank=sink, shape="plaintext"]
    6 [label="(4,4)", rank=sink, shape="plaintext"]
}

1 -> 3 [headlabel="War", labeldistance=3, labelangle=40]
1 -> 4 [headlabel="Peace", labeldistance=3, labelangle=-40]
2 -> 5 [headlabel="War", labeldistance=3, labelangle=40]
2 -> 6 [headlabel="Peace", labeldistance=3, labelangle=-40]
}
@enddot
@startdot
digraph G {
 node [shape=record];
 struct1 [shape=record,label="<f0> left|<f1> mid\ dle|<f2> right"];
 struct2 [shape=record,label="<f0> one|<f1> two"];
 struct3 [shape=record,label="hello\nworld |{ b |{c|<here> d|e}| f}| g | h"];
 struct1 -> struct2;
 struct1 -> struct3;

}
@enddot
@startdot
digraph G {
 a -> b -> c;
 b -> d;
 a [shape=polygon,sides=5,peripheries=10,color=lightblue,style=filled];
 c [shape=polygon,sides=4,skew=.4,label="hello world"]
 d [shape=invtriangle];
 e [shape=polygon,sides=4,distortion=.7];

}
@enddot
@startdot
digraph G {
 size ="4,4";
 main [shape=box]; /* this is a comment */
 main -> parse [weight=8];
 parse -> execute;
 main -> init [style=dotted];
 main -> cleanup;
 execute -> { make_string; printf}
 init -> make_string;
 edge [color=red]; // so is this
 main -> printf [style=bold,label="100 times"];
 make_string [label="make a\nstring"];
 node [shape=box,style=filled,color=".7 .3 1.0"];
 execute -> compare;

}
@enddot
@startdot
digraph G {
 main -> parse -> execute;
 main -> init;
 main -> cleanup;
 execute -> make_string;
 execute -> printf
 init -> make_string;
 main -> printf;
 execute -> compare;
}
@enddot
@startdot
digraph G {
 A [label="King Arthur"]
    B [label="Sir Bedevere the Wise"]
    L [label="Sir Lancelot the Brave"]
    A -> B
    A -> L
    B -> L [constraint=false]
}
@enddot

@startdot
digraph Alexnet {
// ================================================= //
// Author: Miquel Perello Nieto                      //
// Web:    www.perellonieto.com                      //
// Email:  miquel.perellonieto at aalto dot fi       //
// ================================================= //
//
// This is an example to create Alexnet Convolutional Neural Network
// using the opensource tool Graphviz.
//
// Tested with version:
//
//      2.36.0 (20140111.2315)
//
// To generate the graph as a PDF just run:
//
//      dot -Tpdf alexnet.gv -o alexnet.pdf
//
// One think to have in mind is that the order of the nodes definition modifies
// nodes position.


    // ================================== //
    //  GRAPH OPTIONS                     //
    // ================================== //

    // From Top to Bottom
    rankdir=TB;

    // Tittle possition: top
    labelloc="t";
    // Tittle
    label="Alexnet";

    // ================================== //
    //  NODE SHAPES                       //
    // ================================== //
    //
    // There is a shape and color description for each node
    // of the graph.
    //
    // It can be specified individually per node:
    //      first_node [shape=circle, color=blue];
    //
    // Or for a group of nodes if specified previously:
    //      node [shape=circle, color=blue];
    //      first_node;
    //      second_node;
    //

    // Data node
    // =========

    data [shape=box3d, color=black];

    // Label node
    // =========

    label [shape=tab, color=black];

    // Loss function node
    // ==================

    loss [shape=component, color=black];

    // Convolution nodes
    // =================
    //
    // All convolutions are a blue inverted trapezoid
    //

    node [shape=invtrapezium, fillcolor=lightblue, style=filled];
    conv1;
    conv3;
    // Splitted layer 2
    // ================
    //
    //  Layers with separated convolutions need to be in subgraphs
    //  This is because we want arrows from individual nodes but
    //  we want to consider all of them as a unique layer.
    //

    subgraph layer2 {
        // Convolution nodes
        //
        node [shape=invtrapezium, fillcolor=lightblue, style=filled];
        conv2_1;
        conv2_2;
        node [shape=Msquare, fillcolor=darkolivegreen2, style=filled];
        relu2_1;
        relu2_2;
    }

    // Splitted layer 4
    // ================
    //

    subgraph layer4 {
        // Convolution nodes
        //
        node [shape=invtrapezium, fillcolor=lightblue, style=filled];
        conv4_1;
        conv4_2;
        node [shape=Msquare, fillcolor=darkolivegreen2, style=filled];
        relu4_1;
        relu4_2;
    }

    // Splitted layer 5
    // ================
    //

    subgraph layer5 {
        // Convolution nodes
        //
        node [shape=invtrapezium, fillcolor=lightblue, style=filled];
        conv5_1;
        conv5_2;
        // Rectified Linear Unit nodes
        //
        node [shape=Msquare, fillcolor=darkolivegreen2, style=filled];
        relu5_1;
        relu5_2;
    }

    // Rectified Linear Unit nodes
    // ============================
    //
    // RELU nodes are green squares
    //

    node [shape=Msquare, fillcolor=darkolivegreen2, style=filled];
    relu1;
    relu3;
    relu6;
    relu7;

    // Pooling nodes
    // =============
    //
    // All pooling nodes are orange inverted triangles
    //

    node [shape=invtriangle, fillcolor=orange, style=filled];
    pool1;
    pool2;
    pool5;

    // Normalization nodes
    // ===================
    //
    // All normalization nodes are gray circles inside a bigger circle
    // (it reminds me a 3 dimmensional Gaussian looked from top)
    //

    node [shape=doublecircle, fillcolor=grey, style=filled];
    norm1;
    norm2;

    // Fully connected layers
    // ======================
    //
    // All fully connected layers are salmon circles
    //

    node [shape=circle, fillcolor=salmon, style=filled];
    fc6;
    fc7;
    fc8;

    // Drop Out nodes
    // ==============
    //
    // All DropOut nodes are purple octagons
    //

    node [shape=tripleoctagon, fillcolor=plum2, style=filled];
    drop6;
    drop7;

    // ================================== //
    //  ARROWS                            //
    // ================================== //
    //
    // There is a color and possible a label for each
    // arrow in the graph.
    // Also, some nodes has connections going in and
    // going out.
    //
    // The color can be specified individually per arrow:
    // first_node -> second_node [color=blue, style=bold,label="one to two"];
    //
    // Or for a group of nodes if specified previously:
    //  edge [color=blue];
    //  first_node -> second_node;
    //  second_node -> first_node;
    //  second_node -> third_node;
    //

    //
    // LAYER 1
    //

    data -> conv1 [color=lightblue, style=bold,label="out = 96, kernel = 11, stride = 4"];

    edge [color=darkolivegreen2];
    conv1 -> relu1;
    relu1 -> conv1;

    conv1 -> norm1 [color=grey, style=bold,label="local_size = 5, alpha = 0.0001, beta = 0.75"];
    norm1 -> pool1 [color=orange, style=bold,label="pool = MAX, kernel = 3, stride = 2"];

    pool1 -> conv2_1 [color=lightblue, style=bold,label="out = 256, kernel = 5, pad = 2"];
    pool1 -> conv2_2 [color=lightblue, style=bold];

    //
    // LAYER 2
    //

    edge [color=darkolivegreen2];
    conv2_1 -> relu2_1;
    conv2_2 -> relu2_2;
    relu2_1 -> conv2_1;
    relu2_2 -> conv2_2;

    conv2_1 -> norm2 [color=grey, style=bold,label="local_size = 5, alpha = 0.0001, beta = 0.75"];
    conv2_2 -> norm2 [color=grey, style=bold];
    norm2 -> pool2 [color=orange, style=bold,label="pool = MAX, kernel = 3, stride = 2"];

    pool2 -> conv3 [color=lightblue, style=bold,label="out = 384, kernel = 3, pad = 1"];

    //
    // LAYER 3
    //

    conv3 -> relu3 [color=darkolivegreen2];
    relu3 -> conv3 [color=darkolivegreen2];

    conv3 -> conv4_1 [color=lightblue, style=bold,label="out = 384, kernel = 3, pad = 1"];
    conv3 -> conv4_2 [color=lightblue, style=bold];

    //
    // LAYER 4
    //

    edge [color=darkolivegreen2];
    conv4_1 -> relu4_1;
    relu4_1 -> conv4_1;
    conv4_2 -> relu4_2;
    relu4_2 -> conv4_2;

    conv4_1 -> conv5_1 [color=lightblue, style=bold, label="out = 256, kernel = 3, pad = 1"];
    conv4_2 -> conv5_2 [color=lightblue, style=bold];

    //
    // LAYER 5
    //

    edge [color=darkolivegreen2];
    conv5_1 -> relu5_1;
    relu5_1 -> conv5_1;
    conv5_2 -> relu5_2;
    relu5_2 -> conv5_2;

    conv5_1 -> pool5 [color=orange, style=bold,label="pool = MAX, kernel = 3, stride = 2"];
    conv5_2 -> pool5 [color=orange, style=bold];

    pool5 -> fc6 [color=salmon, style=bold,label="out = 4096"];
    fc6 -> relu6 [color=darkolivegreen2];
    relu6 -> fc6 [color=darkolivegreen2];
    fc6 -> drop6 [color=plum2, style=bold,label="dropout_ratio = 0.5"];
    drop6 -> fc6 [color=plum2];

    //
    // LAYER 6
    //

    fc6 -> fc7 [color=salmon, style=bold,label="out = 4096"];

    //
    // LAYER 7
    //

    fc7 -> relu7 [color=darkolivegreen2];
    relu7 -> fc7 [color=darkolivegreen2];
    fc7 -> drop7 [color=plum2, style=bold,label="dropout_ratio = 0.5"];
    drop7 -> fc7 [color=plum2];

    fc7 -> fc8 [color=salmon, style=bold,label="out = 1000"];

    //
    // LAYER 8
    //

    edge [color=black]
    fc8 -> loss;
    label -> loss;
}
@enddot

@startdot
digraph G {
    node [shape=circle];
    a -> b [label="label",lblstyle="draw=red,cross out"];
    b -> c [label="test",lblstyle="below=0.5cm,rotate=20,fill=blue!20"];
    a [label="aa",lblstyle="blue"];
    b [lblstyle="font=\Huge"];
    c [label="ccc", lblstyle="red,rotate=90"];
    label="Graph label";
    lblstyle="draw,fill=red!20";
    rankdir=LR;
}
@enddot

@startdot
digraph G {
node [shape=plaintext fontname="Arial"];

  0  [label="zero"      ];
  1  [label="one"       ];
  2  [label="two"       ];
  3  [label="three"     ];
  4  [label="four"      ];
  5  [label="five"      ];
  6  [label="six"       ];
  7  [label="seven"     ];
  8  [label="eight"     ];
  9  [label="nine"      ];
  10 [label="ten"       ];
  11 [label="eleven"    ];
  12 [label="twelve"    ];
  13 [label="thirteen"  ];
  14 [label="fourteen"  ];
  15 [label="fivteen"   ];
  16 [label="sixteen"   ];
  17 [label="seventeen" ];
  18 [label="eighteen"  ];
  19 [label="nineteen"  ];
  20 [label="twenty"    ];
  21 [label="twenty-one"];
  22 [label="twenty-two"];

  0  -> 1  [arrowhead=none];
  1  -> 2  [arrowhead=none];
  2  -> 7  [arrowhead=none];
  7  -> 8  [arrowhead=none];
  8  -> 9  [arrowhead=none];
  8  -> 10 [arrowhead=none];
  9  -> 10 [color="#aaaaaa" constraint=false];
  10 -> 11 [arrowhead=none];
  10 -> 12 [arrowhead=none];
  11 -> 12 [color="#aaaaaa" constraint=false];
  7  -> 13 [arrowhead=none];
  8  -> 13 [color="#aaaaaa" constraint=false];
  13 -> 14 [arrowhead=none];
  7  -> 15 [arrowhead=none];
  13 -> 15 [color="#aaaaaa" constraint=false];
  15 -> 16 [arrowhead=none];
  15 -> 17 [arrowhead=none];
  16 -> 17 [color="#aaaaaa" constraint=false];
  2  -> 3  [arrowhead=none];
  7  -> 3  [color="#aaaaaa" constraint=false];
  3  -> 4  [arrowhead=none];
  2  -> 5  [arrowhead=none];
  3  -> 5  [color="#aaaaaa" constraint=false];
  5  -> 6  [arrowhead=none];
  2  -> 18 [arrowhead=none];
  5  -> 18 [color="#aaaaaa" constraint=false];
  18 -> 19 [arrowhead=none];
  19 -> 20 [arrowhead=none];
  19 -> 21 [arrowhead=none];
  20 -> 21 [color="#aaaaaa" constraint=false];
  18 -> 22 [arrowhead=none];
  19 -> 22 [color="#aaaaaa" constraint=false];
}
@enddot

@startdot
digraph G {
node [color=Blue,shape=box]

  1.1 [label="Frequency of t exceeds upper threshold"]
  2.1 [label="t has d-mutant tiles"]
  2.2 [label="Valid"]
  3.1 [label="Frequency of t exceeds lower threshold"]
  3.2 [label="Frequency of t exceeds lower threshold"]
  4.1 [label="Insufficient evidence"]
  4.2 [label="Valid"]
  4.3 [label="t has only one d-mutant that exceeds lower threshold"]
  4.4 [label="Are there any d-mutant tiles with significantly higher frequencies?"]
  5.1 [label="Insufficient evidence"]
  node [color=Green] 5.2 [label="Correct t to t'"] node [color=Blue]
  5.3 [label="t has a d-mutant tile t' that is closer than all other d-mutant tiles and for which a corrected base has a higher quality score"]
  5.4 [label="Valid"]
  6.1 [label="Insufficient evidence"]
  6.2 [label="t' is unique"]
  7.1 [label="Insufficient evidence"]
  node [color=Green] 7.2 [label="Correct t to t'"] node [color=Blue]

  1.1 -> 2.1 [label="no"]
  1.1 -> 2.2 [label="yes"]
  2.1 -> 3.1 [label="no"]
  2.1 -> 3.2 [label="yes"]
  3.1 -> 4.1 [label="no"]
  3.1 -> 4.2 [label="yes"]
  3.2 -> 4.3 [label="no"]
  3.2 -> 4.4 [label="yes"]
  4.3 -> 5.1 [label="no"]
  4.3 -> 5.2 [label="yes"]
  4.4 -> 5.3 [label="no"]
  4.4 -> 5.4 [label="yes"]
  5.3 -> 6.1 [label="no"]
  5.3 -> 6.2 [label="yes"]
  6.2 -> 7.1 [label="no"]
  6.2 -> 7.2 [label="yes"]
}
@enddot

@startdot
digraph G {
 a -> b [ label="a to b" labeltooltip="this is a tooltip" ];
 b -> c [ label="another label"];
}
@enddot

@startdot
digraph G {
    d2tdocpreamble = "\usetikzlibrary{automata}";
    d2tfigpreamble = "\tikzstyle{every state}= \
    [draw=blue!50,very thick,fill=blue!20]";
    node [style="state"];
    edge [lblstyle="auto",topath="bend left"];
    A [style="state, initial"];
    A -> B [label=2];
    A -> D [label=7];
    B -> A [label=1];
    B -> B [label=3,topath="loop above"];
    B -> C [label=4];
    C -> F [label=5];
    F -> B [label=8];
    F -> D [label=7];
    D -> E [label=2];
    E -> A [label="1,6"];
    F [style="state,accepting"];
}
@enddot


@startdot
digraph G {
    pad=0.2;
    {
        rank=same;
        node [shape = point, style = invis]; q_0;
        node [shape = doublecircle, style = solid]; q_5;
        node [shape = circle];
        q_1 [ label = <<i>q<sub>1</sub></i>> ];
        q_2 [ label = <<i>q<sub>2</sub></i>> ];
        q_3 [ label = <<i>q<sub>3</sub></i>> ];
        q_4 [ label = <<i>q<sub>4</sub></i>> ];
        q_5 [ label = <<i>q<sub>5</sub></i>> ];
        q_0 -> q_1;
        q_1 -> q_2 [ label = "." ];
        q_1 -> q_2 [ label = <&epsilon;>, constraint=false ];
        q_2 -> q_1 [ label = <&epsilon;>, constraint=false ];
        q_2 -> q_3 [ label = <<i>a</i>> ];
        q_3 -> q_4 [ label = <<i>^a</i>> ];
        q_3 -> q_4 [ label = <&epsilon;>, constraint=false ];
        q_4 -> q_3 [ label = <&epsilon;>, constraint=false ];
        q_4 -> q_5 [ label = <<i>b</i>> ];
        q_1 -> q_2 [ label = <<table cellpadding="10" border="0" cellborder="0">
                                <tr><td>&epsilon;</td></tr>
                              </table>>,
                     constraint = false ];
    }
}
@enddot

@startdot
digraph G {
  graph [label="Orthogonal edges", splines=ortho, nodesep=0.8]
  node [shape=box]
  a->{b c}
  b->{d e}
  c->{f g}
}
@enddot

@startdot
digraph uart_flow {
rankdir=LR

start [style = rounded, shape = rect, label="RX event"]
handler [style = rounded, shape = rect, label="Call\nhandler"]
header_done [shape=diamond, label="Header\nreceived?"]
has_payload [shape=diamond, label="Has\npayload?"]
payload_done [shape=diamond, label="Payload\nreceived?"]

{ edge [weight=100]
start -> header_done
{ edge [label="Yes"]
header_done -> has_payload
has_payload -> payload_done
payload_done -> handler
}
}
{ edge [label="No"]
header_done:s -> start:s
has_payload:s -> handler:s
payload_done:n -> start:n
}
}
@enddot

@startdot
digraph G {
rankdir=LR; fontname="sans-serif"; penwidth="0.1"; edge [comment="Wildcard edge", fontname="sans-serif", fontsize=10, colorscheme="blues3", color=2, fontcolor=3]; node [fontname="serif", fontsize=13, fillcolor="1", colorscheme="blues4", color="2", fontcolor="4", style="filled"]; "a"; "b"; "a" -> "b" [dir="both"];
}
@enddot

@startdot
digraph G {
 rankdir=LR; /* graph from left to right */
fontname=ubuntu; /* ubuntu is our standard font */
labeljust=l; /* cluster labels aligned left */
splines=ortho; /* arrows are straight and w 90 deg angles */
penwidth=2; /* for cluster borders */
color=gray; /* for cluster borders */

/* default node config: */
node [shape=box fontsize=14 width=1.5 height=1 fixedsize=true ]

subgraph cluster0
{

{
rank = same; /* rank=same aligns both elements */
a;
aout
}
subgraph cluster3{
margin=8
style=dashed
color=grey
choice [height=2.2 width=1]
b
c
}
d
aout -> a
a -> choice
choice -> {b c}
{b c} -> d
d -> aout [tailport=s headport=e color=blue constraint=false] /* arrow leaves south of block, reaches east of another block, same as saying: d:s -> aout:e */

}
}
@enddot


@startdot
graph g {

ratio=fill
splines=spline
overlap=scale

node [shape=circle,
      fixedsize=true,
      width=0.3,
      color="black",
      fillcolor="#eeeeee",
      style="filled,solid",
      fontsize=12]

q0 [label="0", xlabel="000", pos="0,0"]
q1 [label="1", xlabel="001", pos="0,1"]
q2 [label="2", xlabel="010", pos="1,0"]
q3 [label="3", xlabel="011", pos="1,1"]

q4 [label="4", xlabel="100", pos="-0.5,-0.5"]
q5 [label="5", xlabel="101", pos="-0.5,0.5"]
q6 [label="6", xlabel="110", pos="0.5,-0.5"]
q7 [label="7", xlabel="111", pos="0.5,0.5"]

q0--q1
q0--q2
q1--q3
q2--q3

q4--q5
q4--q6
q5--q7
q6--q7

q0--q4
q1--q5
q2--q6
q3--q7
}
@enddot

@startdot
graph g {

bgcolor="#ffffff00"
overlap=scale

layout=fdp

start=2
edge [penwidth=0.75,arrowsize=0.6]
edge [color=black, fontsize=8, forcelabels=true]

node [shape=circle,
      fixedsize=true,
      width=0.25,
      color="black",
      fillcolor="white",
      style="filled,solid",
      fontsize=12];


node1 [label="s₁"] # u+2081 (yes, it can do unicode!)
node2 [label="s₂"]
node3 [label="s₃"]
node4 [label="t₁",pos="0,0"]
node5 [label="t₂",pos="0,1"]
node6 [label="t₃",pos="1,1"]
node7 [label="t₄",pos="1,0"]

subgraph clusterG0 {
    label="G∪T" # union u+222a


    subgraph clusterG1 {
            label="G"
            bgcolor=white
            node1--node2
            node2--node3
            node3--node1
    }

    node3--node6[style=dashed,penwidth=1]

    subgraph clusterG2 {
            label="H"
            bgcolor=white
            node4--node5
            node5--node6
            node6--node4
            node6--node7
    }
}

}
@enddot



@startdot
digraph G {
bgcolor="#ffffff00" # RGBA (with alpha)
splines=true
overlap=scale

node [shape=circle,
      fixedsize=true,
      width=0.25,
      color="black", # node border color (X11 or HTML colors)
      fillcolor=white, # node fill color (X11 or HTML colors)
      style="filled,solid",
      fontcolor=darkred, # text color (X11 or HTML colors)
      fontsize=12]

edge [ penwidth=0.75, color=black ]

node1 [label="1"]
node2 [label="2"]
node3 [label="3"]
node4 [label="4"]
node5 [label="5"]
node6 [label="6"]
node7 [label="7"]

node1 -> node2
node1 -> node3
node1 -> node4
node1 -> node5

node2 -> node3
node2 -> node4
node2 -> node6

node3 -> node4
node4 -> node5
node4 -> node7
node4 -> node6

node5 -> node7}
@enddot

@startdot
digraph G {
rankdir=LR
a->b[dir=both]
b->c[dir=both,label="        "]// Just use the space to increase the edge length
}
@enddot

@startdot
digraph G {
 rankdir="LR";
  //orientation=landscape;
    node [shape=ellipse, fontsize=30];
  {node [label="Original"] old;}
  {node [label="Final"] new;}
  {node [label="Intermediate"] ir;}

old -> ir [label="suggest", fontsize=30];
ir -> ir [label="validate", fontsize=30, len=f];
ir -> new [label = "finalize", fontsize=30];
}
@enddot

@startdot
digraph G {
 rankdir="LR";
  dpi=300;
  node[
    fontname="Arial",
    shape="square",
    fixedsize=false,
    width=1.809,
    style=rounded
  ];

  edge [
    arrowhead="none"
  ];

  Node1 -> Node2;
  Node2 -> Node3;
  Node3 -> Node4;
}
@enddot

@startdot
digraph G {
  rankdir=BT // Graph direction : Bottom-Top
  node [shape=record] // all nodes are in Box shape
  edge [dir=normal labeldistance=1] // "labeldistance=1" is default value

  // Multiplicity types by Crow's Foot Notation
  Member1 -> Group1 [dir=both arrowtail=crowodot arrowhead=teetee label="0or* to 1"]
  Member2 -> Group2 [dir=both arrowtail=teeodot arrowhead=teetee label="0or1 to 1"]
  Member3 -> Group3 [dir=both arrowtail=crowtee arrowhead=crowodot label="1or* to 0or*"]

}
@enddot


@startdot
digraph G {
  rankdir=BT // Graph direction : Bottom-Top
  node [shape=record] // all nodes are in Box shape
  edge [dir=normal labeldistance=1] // "labeldistance=1" is default value

  // Multiplicity types by Crow's Foot Notation
  Member1 -> Group1 [dir=both arrowtail=crowodot arrowhead=teetee label="0or* to 1"]
  Member2 -> Group2 [dir=both arrowtail=teeodot arrowhead=teetee label="0or1 to 1"]
  Member3 -> Group3 [dir=both arrowtail=crowtee arrowhead=crowodot label="1or* to 0or*"]

}
@enddot


@startdot
digraph G {
//rankdir=LR // from bottom to top
node[shape=record]

// User, Role, and Assignment
_UserRole [shape=point label=""]
User -> _UserRole [dir=both arrowtail=crowodot arrowhead=none taillabel="has"]
_UserRole -> Role [dir=both arrowtail=none arrowhead=crowodot]
Assignment -> _UserRole [style=dotted arrowhead=none]

// User, Session and Role
Session -> User [dir=both arrowtail=crowodot arrowhead=teetee headlabel="establishes" taillabel="_"] // empty label
Session -> Role [dir=both arrowtail=crowodot arrowhead=crowodot taillabel="___activates"] // use _ instead of whitespace

// Role inheritance
Role -> Role [arrowhead=onormal taillabel="inherits"]

// Role and Permission
Role -> Permission [dir=both arrowtail=crowodot arrowhead=crowodot taillabel="has"]

// Operation and Resource, and the ASSOCIATION with Permission
_OperationResource [shape=point label=""]
Operation -> _OperationResource [dir=both arrowtail=crowodot arrowhead=none]
_OperationResource -> Resource [dir=both arrowtail=none arrowhead=crowodot]
Permission -> _OperationResource [style=dotted arrowhead=none]
}
@enddot

@startdot
digraph G {
 a;
  ab[label="", fixedsize="false", width=0, height=0, shape=none];
  b;
  c;

  a -> ab[arrowhead=None];
  ab -> b;
  c -> ab;
}
@enddot

@startdot
digraph G {
  ab[label="", fixedsize="false", width=0, height=0, shape=none];

  a -> ab[arrowhead=None];
  ab -> b;
  c -> ab;

  {rank=same; a; ab; b};
}
@enddot

@startdot
digraph G {
rankdir=LR;
  size="8,5";
  concentrate=true;

  node  [style="rounded,filled,bold", shape=box, fixedsize=true, width=1.3, fontname="Arial"];
  Created   [fillcolor=black, shape=circle, label="", width=0.25];
  Destroyed [fillcolor=black, shape=doublecircle, label="", width=0.3];
  Empty     [fillcolor="#a0ffa0"];
  Failed    [fillcolor="#ffa0a0"];
  Announced [fillcolor="#a0ffa0"];
  Assigned  [fillcolor="#a0ffa0"];
  Working   [fillcolor="#a0ffa0"];
  Ready     [fillcolor="#a0ffa0"];
  TimedOut  [fillcolor="#ffa0a0"];

  {
    rank=source; Created; Destroyed;
  }
  {
    rank=same;Announced;Failed;
  }
  {
    rank=same;Assigned;TimedOut;
  }

  edge  [style=bold, fontname="Arial", weight=100]
  Empty     -> Announced [ label="announce"   ];
  Announced -> Assigned  [ label="assign"     ];
  Assigned  -> Working   [ label="start"      ];
  Working   -> Ready     [ label="finish"     ];
  Ready     -> Empty     [ label="revoke", weight=1     ];

  edge  [color="#aaaaaa", weight=1]
  Announced -> TimedOut  [ label="timeout"    ];
  Assigned  -> TimedOut  [ label="timeout"    ];
  Working   -> TimedOut  [ label="timeout"    ];
  Working   -> Failed    [ label="error"      ];
  TimedOut  -> Announced [ label="announce"   ];
  TimedOut  -> Empty     [ label="revoke"     ];
  Failed    -> Announced [ label="announce"   ];
  Failed    -> Empty     [ label="revoke"     ];

  Created   -> Empty     [ label="initialize" ];
  Empty     -> Destroyed [ label="finalize"   ];
  Announced -> Empty     [ label="revoke"     ];
  Assigned  -> Empty     [ label="revoke"     ];
  Working   -> Empty     [ label="revoke"     ];
}
@enddot
@startdot
digraph G {
rankdir=LR;
     size="8,5";

     node  [style="rounded,filled,bold", shape=box, fixedsize=true, width=1.3, fontname="Arial"];
     Created   [fillcolor=black, shape=circle, label="", width=0.25];
     Destroyed [fillcolor=black, shape=doublecircle, label="", width=0.3];
     Empty     [fillcolor="#a0ffa0"];
    Announced [fillcolor="#a0ffa0"];
    Assigned  [fillcolor="#a0ffa0"];
    Working   [fillcolor="#a0ffa0"];
    Ready     [fillcolor="#a0ffa0"];
    TimedOut  [fillcolor="#ffa0a0"];
    Failed    [fillcolor="#ffa0a0"];

    {
      rank=source; Created Destroyed;
    }

    edge  [style=bold, fontname="Arial" weight=2]
    Empty     -> Announced [ label="announce"   ];
    Announced -> Assigned  [ label="assign"     ];
    Assigned  -> Working   [ label="start"      ];
    Working   -> Ready     [ label="finish"     ];
    Ready     -> Empty     [ label="revoke"     ];

    edge  [fontname="Arial" color="#aaaaaa" weight=1]
    Announced -> TimedOut  [ label="timeout"    ];
    Assigned  -> TimedOut  [ label="timeout"    ];
    Working   -> TimedOut  [ label="timeout"    ];
    Working   -> Failed    [ label="error"      ];
    TimedOut  -> Announced [ label="announce"   ];
    TimedOut  -> Empty     [ label="revoke"     ];
    Failed    -> Announced [ label="announce"   ];
    Failed    -> Empty     [ label="revoke"     ];

    edge  [style=bold, fontname="Arial" weight=1]
    Created   -> Empty     [ label="initialize" ];
    Empty     -> Destroyed [ label="finalize"   ];
    Announced -> Empty     [ label="revoke"     ];
    Assigned  -> Empty     [ label="revoke"     ];
    Working   -> Empty     [ label="revoke"     ];
}
@enddot

@startdot
digraph G {
color = white;
labelloc="c"
label = "process #2";
b0 [shape=ellipse];
}
@enddot
@startdot
digraph G {
  edge [dir="back"];
  a -> b;
  c -> a;
}
@enddot
@startdot
digraph G {
  a -> b;
  c -> a [dir="back"];
  {rank=same;c a b}
}
@enddot

@startdot
digraph G {
 rankdir = LR;
    {rank=same; S; A}
    B -> A -> T;
    B -> S -> T;
    A -> A;
    S -> S;
    A -> S[dir=both];
}
@enddot

Controller -> View;

@startdot
digraph G {
    dir="forward"; /* implied */
    A -> B [label="foo"];
    A -> B [label="bar"];
    B -> A;
    C;
}
@enddot

@startdot
digraph G {
    dir="back"; /* note the change to this line */
    A -> B [label="foo"];
    A -> B [label="bar"];
    B -> A;
    C;
}
@enddot

@startdot
digraph G {
A -> B [label="foo"];
A -> B [label="bar"];
B -> A; C;
}
@enddot

@startdot
digraph G {
    A -> B [key=2];
    B -> A [key=0, label=foo];
    B -> A [key=1, label=bar];
    C;
}
@enddot

@startdot
graph G {
  a -- b
  a -- b
  b -- a [color=blue]
}
@enddot

'Model -> Controller;






/'Employees -> Employees;
EmployeeTerritories -> Employees;
EmployeeTerritories -> Territories;
Order Details -> Orders;
Order Details -> Products;
Orders -> Customers;
Orders -> Employees;
Orders -> Shippers;
Products -> Categories;
Products -> Suppliers;
Territories -> Region;
'/

@startuml
skinparam handwritten true
skinparam monochrome true
skinparam packageStyle rect
skinparam defaultFontName Buxton Sketch
skinparam shadowing false

actor Phil #black
actor Editor #grey
Phil -> Editor: Is the style a bit dated?
Editor --> Phil: Yes, it is a bit nineties

Phil -> Editor: How about a more handwritten 'arty' look?
Editor --> Phil: Sure, how about this?

@enduml

@startuml
graph G {
a -- b[label="0.1",weight="0.1"];
b -- c[label="0.2",weight="0.1"];
a -- c[label="0.3",weight="0.3"];
d -- c[label="0.4",weight="0.4"];
e -- c[label="0.5",weight="0.6"];
e -- a[label="0.6",weight="0.3"];
a -- a;
}
@enduml


a -- b;
b -- c;
a -- c;
d -- c;
e -- c;
e -- a;

@startuml
digraph data_relationships {
  "org-mode"
  "org-exp-blocks"
  "dot"
  "ditaa"
  "HTML" [shape=Mrecord, label="{HTML|publish on the web\l}"]
  "LaTeX" [shape=Mrecord, label="{LaTeX|publish in PDF\l}"]
  "org-mode" -> "org-exp-blocks"
  "dot" -> "org-mode"
  "ditaa" -> "org-mode"
  "org-exp-blocks" -> "HTML"
  "org-exp-blocks" -> LaTeX
}
@enduml


@startditaa
               O
              -|- -.
              / \   |
              User  | Request
                    V
 Foobar         +--------+       .------.
  Layer         |  Acme  |       '------'
- - - - - - +   | Widget |<----->|      |
   .----.   ;   +--------+       |      |
  | do-  |  ;       |            '------'
  |  dad |--^--<|---+            Database
   '----'   ;
            ;
@endditaa

@startditaa

                          +-------------+
                          |             |
                          | Exponential |
                          |             |
                          +-------------+
                                 |
                          lambda |
                                 v
+-------------+           +-------------+           +-------------+
|             |   tau     |             |   lambda  |             |
|  Lognormal  |---------->|    Gamma    |<----------| Poisson     |
|             |           |             |---+       |             |
+-------------+           +-------------+   |       +-------------+
      |                         ^ ^         | beta
      |                   tau   | |         |
      | tau                     | +---------+
      |                   +-------------+
      +------------------>|             |
                          |     Normal  |
                          |             |----+
                          +-------------+    |
                                     ^       | mu
                                     |       |
                                     +-------+
@endditaa



@startuml
digraph G {
  rankdir=LR;
  size="7,5";
  browser->thread[style=invis];
  browser->ui_thread;
  browser->db_thread;
  browser->webkit_thread;
  browser->cache_thread;
  browser->file_thread;
  browser->io_thread;
  io_thread[style=filled];
  cache_thread[style=filled];
  ui_thread->thread[label=inherit constraint=false];
  ui_thread->messageloop[style=dotted];
  db_thread->messageloop[style=dotted];
  webkit_thread->messageloop[style=dotted];
  cache_thread->messageloop[style=dotted];
  file_thread->messageloop[style=dotted];
  io_thread->messageloop[style=dotted];
}
@enduml

@startuml
together {
   interface Widget {
     callFred()
     callBarney()
   }

   class A
   class B
   class C
}

Widget ()- A
Widget ()- B
Widget ()- C
@enduml

@startuml
|Swimlane1|
start
:OP1;
|Swimlane2|
while (Form Valid) is (no)
:OP2;
|Swimlane1|
:Modify Details;
endwhile (yes)
|Swimlane2|
:Add Detals to System;
:OP3;
:foo5;
stop
@enduml

@startuml
skinparam rectangle<<desc>> {
    backgroundColor Transparent
    borderColor Transparent
    titleFontColor Red
    stereotypeFontColor Transparent
}

folder folder2 {
    folder folder3 [
        text bla bla
    ]
    artifact art2 [
        more text
    ]
    rectangle f2<<desc>> [
        Here you can have some explanation with
        ====
        --Markdown-- //formatting// ~~elements~~
    ]

    folder3 -[hidden]- f2
}
@enduml

@startuml
folder folder2 {
    folder folder3 [
        text bla bla
    ]
    artifact art2 [
        more text
    ]
}

note bottom of folder2
    Here you can have some explanation with
    ====
    --Markdown-- //formatting// ~~elements~~
end note
@enduml

@startuml
participant T1
participant T2
participant Main

par
    T1 -> Main ++ #red: start
    Main --> T1 -- #red : done

    else

    T2 -> Main ++ #yellow: start
    Main --> T2 -- #yellow : done
end
@enduml

@startuml

  actor Member

  memberTypeA --|> Member
  memberTypeB --|> Member
  memberTypeC --|> Member

@enduml

@startuml
digraph G {
  rankdir=LR;
  size="7,5";
  browser->ui_thread;
  browser->db_thread;
  browser->webkit_thread;
  browser->cache_thread;
  browser->file_thread;
  browser->io_thread;
  io_thread[style=filled];
  cache_thread[style=filled];
  ui_thread->thread[label=inherit];
  ui_thread->messageloop[style=dotted];
  db_thread->messageloop[style=dotted];
  webkit_thread->messageloop[style=dotted];
  cache_thread->messageloop[style=dotted];
  file_thread->messageloop[style=dotted];
  io_thread->messageloop[style=dotted];
}
@enduml

@startuml
graph G {
      splines=false;
      node[shape=circle, style=filled]
      subgraph cluster_1 {

      subgraph cluster_1r {
         a12 [label="a",fillcolor=lightgrey]
         b12 [label="b",fillcolor=lightgrey]
         c12 [label="c",fillcolor=lightgrey]
         d12 [label="d",fillcolor=lightgrey]
         e12 [label="e",fillcolor=lightgrey]
         a12--b12--c12--d12--e12 [style=invis]
         }
         subgraph cluster_1m {
            color=invis;
            a12m [style=invisible]
            }
      subgraph cluster_1l {
         a11 [label="a",fillcolor=white]
         b11 [label="b",fillcolor=white]
         c11 [label="c",fillcolor=white]
         d11 [label="d",fillcolor=white]
         e11 [label="e",fillcolor=white]
         a11--b11--c11--d11--e11 [style=invis]
         }
         c11--a12 [constraint=false]
         c11--b12 [constraint=false]
         d11--b12 [constraint=false]
         e11--a12 [constraint=false]
         e11--b12 [constraint=false]
     }
}
@enduml

@startditaa
PerformTests;                                     PerformTests<-----+
PerformTests -> TestsPassed;                            |           |
TestsPassed [shape="diamond"];                          v     N     |
TestsPassed -> Release [label="Yes"];             TestsPassed --> FixErrors
TestsPassed:e -> FixErrors [label="No"];               Y|
FixErrors -> PerformTests;                              v
                                                     Release
@endditaa

@startditaa
+--------+   +-------+    +-------+
|        +---+ ditaa +--> |       |
|  Text  |   +-------+    |diagram|
|Document|   |!magic!|    |       |
|     {d}|   |       |    |       |
+---+----+   +-------+    +-------+
	:                         ^
	|       Lots of work      |
	+-------------------------+
@endditaa

@startuml
ditaa(--no-shadows, scale=0.8)
/--------\   +-------+
|cAAA    +---+Version|
|  Data  |   |   V3  |
|  Base  |   |cRED{d}|
|     {s}|   +-------+
\---+----/
@enduml

@startdot
digraph foo {
  node [style=rounded]
  node1 [shape=box]
  node2 [fillcolor=yellow, style="rounded,filled", shape=diamond]
  node3 [shape=record, label="{ a | b | c }"]

  node1 -> node2 -> node3
}
@enddot

@startuml
digraph G {
    /* declare the node & style them */
    "Node 1" [shape=diamond, penwidth=1, style=filled, fillcolor="#FCD975"];
    "Node 2" [style=filled,fillcolor="#9ACEEB" ];
    "Node 3" [shape=diamond, style=filled, fillcolor="#FCD975" ];
    "Node 4" [style=filled, fillcolor="#9ACEEB" ]

    /* declare the edges & style them */
    "Node 1" -> "Node 2" [dir=none, weight=1, penwidth=3] ;
    "Node 1" -> "Node 3" [dir=none, color="#9ACEEB"] ;
    "Node 1" -> "Node 4" [arrowsize=.5, weight=2.]
}
@enduml

@startuml
participant Alice
participant "The **Famous** Bob" as Bob
Alice -> Bob : hello --there--
... Some ~~long delay~~ ...
Bob -> Alice : ok
note left
This is **bold**
This is //italics//
This is ""monospaced""
This is --stroked --
This is __underlined__
This is ~~waved~~
end note
Alice -> Bob : A //well formatted// message
note right of Alice
This is <back:cadetblue ><size:18>displayed </size></back>
__left of__ Alice.
end note
note left of Bob
<u:red>This</u> is <color #118888>displayed </color>
**<color purple>left of</color> <s:red>Alice </strike> Bob**.
end note
note over Alice, Bob
<w:#FF33FF>This is hosted </w> by <img https://i.stack.imgur.com/eieWA.png>
end note
@enduml

 @startuml

      'style options
      skinparam monochrome true
      skinparam circledCharacterRadius 9
      skinparam circledCharacterFontSize 8
      skinparam classAttributeIconSize 0
      hide empty members

      abstract class AbstractClass {
        - privateField
        + publicField
        # protectedField
        ~ packagePrivateField
        - privateMethod()
        + publicMethod()
        # protectedMethod()
        ~ packagePrivateMethod()
         }

      class Dummy {
        {static} staticID
        {abstract} void methods()
         }

      class Flight {
         flightNumber : Integer
         departureTime : Date
         }

      package "Classic Collections" {

         abstract class AbstractList
         abstract AbstractCollection
         interface List
         interface Collection

         List <|-- AbstractList
         Collection <|-- AbstractCollection

         Collection <|- List
         AbstractCollection <|- AbstractList
         AbstractList <|-- ArrayList

         class ArrayList {
           Object[] elementData
           size()
            }
      }

      enum TimeUnit {
        DAYS
        HOURS
        MINUTES
      }


      class Student {
        Name
      }
      Student "0..*" -- "1..*" Course
      (Student, Course) .. Enrollment

      class Enrollment {
        drop()
        cancel()
      }

      @enduml

@startuml



hide empty members
hide circle
skinparam classarrowcolor gray

HumanResources.vEmployeeDepartmentHistory --|> HumanResources.Department:References
HumanResources.vEmployeeDepartmentHistory --|> HumanResources.Employee:References
HumanResources.vEmployeeDepartmentHistory --|> HumanResources.EmployeeDepartmentHistory:References
HumanResources.vEmployeeDepartmentHistory --|> Person.Person:References
HumanResources.vEmployeeDepartmentHistory --|> HumanResources.Shift:References

@enduml

@startuml

/' Set custom background colors for the default
   component elements and the specific stereotypes. '/
skinparam component {
    BackgroundColor #ff6666
    BackgroundColor<<Database>> #ccff66
    BackgroundColor<<Spring service>> #66ccff
    BackgroundColor<<Spring REST controllers>> #66ffcc
    BackgroundColor<<Spring repository>> #66ffff
    BackgroundColor<<Mail server>> #ffcc66
}

actor User
[Third party application] as ThirdPartyApp

together {
    [PostgreSQL database] as PostgresDB <<Database>>
    [Mail server] as Mail <<Mail server>>
}

package "Spring Boot Application" {
    [APIController] <<Spring REST controllers>>
    [AdminController] <<Spring REST controllers>>

    [AdminService] <<Spring service>>
    [DataStoreService] <<Spring service>>

    [Repository] <<Spring repository>>
}

User --> AdminController
ThirdPartyApp --> APIController

APIController --> DataStoreService
AdminController --> DataStoreService
AdminController --> AdminService

DataStoreService --> Repository
AdminService --> Mail

Repository --> PostgresDB

@enduml

@startuml
digraph G {
node1[label="Some Complicated Label"];
		node1 -> node2[label="An Edge",color=red,fillcolor="blue"
		,weight=0.5,penwidth=4.0,arrowhead=vee, arrowsize=2
		,constraint=true,decorate=true,dim=1];
		node2 -> node3;

		node1 -> node2[label="edge1"];
        		node2 -> node3[label="edge2"];

        		node1 -> node2[label="0.2"];
                		node2 -> node3[label="0.2"];
}
@enduml


@startuml
digraph G {
    node [shape=plaintext]
    struct1 [label=<
<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0">
  <TR><TD>left</TD><TD PORT="f1">mid dle</TD><TD PORT="f2">right</TD></TR>
</TABLE>>];
    struct2 [label=<
<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0">
  <TR><TD PORT="f0">one</TD><TD>two</TD></TR>
</TABLE>>];
    struct3 [label=<
<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0" CELLPADDING="4">
  <TR>
    <TD ROWSPAN="3">hello<BR/>world</TD>
    <TD COLSPAN="3">b</TD>
    <TD ROWSPAN="3">g</TD>
    <TD ROWSPAN="3">h</TD>
  </TR>
  <TR>
    <TD>c</TD><TD PORT="here">d</TD><TD>e</TD>
  </TR>
  <TR>
    <TD COLSPAN="3">f</TD>
  </TR>
</TABLE>>];
    struct1:f1 -> struct2:f0;
    struct1:f2 -> struct3:here;
}
@enduml
/'
http://melp.nl/2013/08/flow-charts-in-code-enter-graphviz-and-the-dot-language/
'/

@startuml
digraph G {
{
rank = same;
SatisfactionF [style=filled, shape = rectangle]
SatisfactionM [style=filled, shape = rectangle]
}
Marital[shape = circle]

       SatisfactionF -> Marital
       SatisfactionM -> Marital


SatisfactionF -> SatisfactionM [label = "0.4" tailport=n headport=n dir=both arrowhead=none]

}
@enduml

@startuml
digraph G {
 fontname = "Microsoft YaHei";
     rankdir = TB;
     fontsize = 12;

     node [fontname = "Microsoft YaHei", fontsize = 12, shape = "record" ];
     edge [fontname = "Microsoft YaHei", fontsize = 12 ];

         subgraph cluster_sl{
             label="IDP支持层";
             bgcolor="mintcream";
             node [shape="Mrecord", color="skyblue", style="filled"];
             network_mgr [label="网络管理器"];
             log_mgr [label="日志管理器"];
             module_mgr [label="模块管理器"];
             conf_mgr [label="配置管理器"];
             db_mgr [label="数据库管理器"];
         };

         subgraph cluster_md{
             label="可插拔模块集";
             bgcolor="lightcyan";
             node [color="chartreuse2", style="filled"];
             mod_dev [label="开发支持模块"];
             mod_dm [label="数据建模模块"];
             mod_dp [label="部署发布模块"];
         };

     mod_dp -> mod_dev [label="依赖..."];
     mod_dp -> mod_dm [label="依赖..."];
     mod_dp -> module_mgr [label="安装...", color="yellowgreen", arrowhead="none"];
     mod_dev -> mod_dm [label="依赖..."];
     mod_dev -> module_mgr [label="安装...", color="yellowgreen", arrowhead="none"];
     mod_dm -> module_mgr [label="安装...", color="yellowgreen", arrowhead="none"];
}
@enduml

@startuml
digraph G {
 rankdir=LR;
    ranksep=0.65;
    nodesep=0.40;
    splines=false;
    overlap=false;
    concentrate=false;
    node[shape=box];
    subgraph clusterAPP {
            label="Application";
            style=dashed;
            nodeA[label="d = func(...);"];

    };
    subgraph clusterFB{
            color=red;
            label="Wrapper";
            style=dashed;
            rank=same;
            wrapper[label="wrapper"];
            real[label="pointer to\nreal func"];
    }
    subgraph clusterBACKEND {
            label="Backend"
            style=dashed;
            func[label="float func(...)"];
    };

    nodeA -> wrapper;
    wrapper -> real [constraint=false, dir=back, label="dlopen\ndlsym"];  // Added reverse direction
    real -> func [weight=10]                    // Remains unaltered
    real -> func [constraint=false, dir=back]   // Remove the constraint and reverse the edge
    func -> real [style=invis]                  // Hide the edge pointing pack

}
@enduml


@startuml
digraph G {
 Start[shape = doublecircle, group=a];
    Foo[shape = square, group=a];
    Bar[shape = diamond, group=a];
    Xyz[shape = square];
    Baz[shape = square];

    Start -> Foo;
    Foo:s -> Bar:n;
    Bar:e -> Baz:n;
    Bar:w -> Xyz:n;
    Baz:s -> Foo:n[constraint=false];
}
@enduml

@startuml
digraph G {
 graph [
        compound = true     // To clip the head at the cluster border
        penwidth = 2        // Make the cluster's borders a bit thicker
        rankdir = "LR"      // Make the arrow and nodes go from Left to Right
        ranksep = 1         // Add a bit more space inbetween nodes
    ]

    node [
        color = none        // Hide the node's border
        fontname = "Bitstream Vera Sans"
        height = 0          // Make the node as small as possible (it will grow if it needs more space)
        margin = 0          // Remove unneeded whitespace
        shape = "record"    // So we can use ports
    ]

    edge [
        arrowhead = "open"
        labelangle = -5     // Place the asteriks closer to the line
        labeldistance = 2.5 // Place the asteriks further away from the arrow head
        penwidth = 2        // Make the line a bit thicker
    ]

    /* @NOTE: escaping spaces in the label using '\' doesn't work so use '&nbsp' or '&#92' instead. */
    subgraph cluster_Person {
        Person [
            label = "\N\l | &#92; &#92; &#92;  age : int\l | <livesIn> &#92; &#92; &#92;  livesIn : City\l | &#92; &#92; &#92; &#92; &#92; &#92;  sinceYear : int\l"
        ]
    }

    subgraph cluster_City {
        City [
            label = "<city> \N\l | &#92; &#92; &#92;  name : string\l"
        ]
    }

    Person:livesIn -> City:city [headlabel = "*", lhead = "cluster_City"] // lhead allows us to point to the cluster's border instead of the node, as long as we add `compound = true` to the graph
}
@enduml


@startuml
digraph G {
 node [shape=plaintext, fontsize=16];

    past -> 1933 -> 1943 -> 1988 -> 2001 -> 2015 -> future;

    {
        node [fontsize=14];
        edge [style=invis];

        a -> b -> c -> d -> e -> f -> g;
    }

    {rank=same past -> a }
    {rank=same 1943 -> c }
    {rank=same future  g }   }
@enduml


@startuml
digraph G {
graph [rankdir="LR" ,compound="true",nodesep=6, ranksep=4 ];
    subgraph cluster0 {
        graph [label="Ready\n\nAllowed Purchaser Operations:\noperation1,operation2\n\nAllowed Supplier Operations:\noperation1,operation3"  ];
        1 [ shape="none" ,fontcolor="white"  ];
    };
    subgraph cluster2 {
        graph [label="Paused\n\nAllowed Purchaser Operations:\noperation1,operation3\n\nAllowed Supplier Operations:\noperation2,operation3" ];
        3 [ shape="none" ,fontcolor="white"  ];
    };
    subgraph cluster4 {
        graph [label="Completed\n\nAllowed Purchaser Operations:\noperation4\n\nAllowed Supplier Operations:\noperation4" ];
        5 [ shape="none" ,fontcolor="white"  ];
    };
    1 -> 3 [ ltail="cluster0" ,lhead="cluster2" ,comment="6"  ];
    1 -> 5 [ ltail="cluster0" ,lhead="cluster4" ,comment="7"  ];
    3 -> 1 [ ltail="cluster2" ,lhead="cluster0" ,comment="8"  ];
    3 -> 5 [ ltail="cluster2" ,lhead="cluster4" ,comment="9"  ];
       }
@enduml

@startuml
digraph G {
 fontname="Helvetica";
    labelloc=t;
    rankdir=LR;
    label="Course Graph";

    node[style=filled, fontname="Helvetica", colorscheme=greens3, color=1];

    subgraph cluster_key {
        //rank=min; /* this doesn't really do anything for you */

        label="Key";
        //rankdir=LR; /* this is also not needed*/

        kc1[label="Course", peripheries=2, color=2];
        k1[shape=plaintext, style=solid, label="Required Course\r", width=3.5] // Add fixed width so all nodes line up

        prereq[label="Course 1"];
        kc2[label="Course 2"];
        prereq->kc2;
        k2[shape=plaintext, style=solid, label="Course 1 is a prerequisite for Course 2\r", width=3.5]  // Add fixed width

        coreq1[label="Course 1"];
        coreq2[label="Course 2"];
        coreq1->coreq2[dir=both];
        k3[shape=plaintext, style=solid, label="Course 1 and Course 2 are corequisite\r", width=3.5]    // Add fixed width

        or[style="dashed", color="black", shape="diamond", label="OR"];
        or1[label="Course 1"];
        or1 -> or[style="dashed", dir="none"];
        or2[label="Course 2"];
        or2 -> or[style="dashed", dir="none"];
        kc3[label="Course 3"]
        or->kc3;
        k4[shape=plaintext, style=solid, label="You must take either Course 1 OR\rCourse 2 before taking Course 3\r", width=3.5] // Add fixed width

        { rank=source;k1 k2 k3 k4 } // Use "source in stead of min
    }

    c3[color=3, peripheries=2];
    c4[color=3, peripheries=2];

    c1->c2[dir=both];
    c2->c3;

    c4_reqs[style="dashed", color="black", shape="diamond", label="OR"];
    c4_reqs->c4;
    c2->c4_reqs[style="dashed", dir="none"];
    c5->c4_reqs[style="dashed", dir="none"];
       }
@enduml


@startuml
digraph G {
  rankdir=LR
   node [shape=plaintext]
   graph [splines=ortho]
   subgraph cluster_01 {
     label = "Legend";
     key [label=<<table border="0" cellpadding="2" cellspacing="0" cellborder="0">
       <tr><td align="right" port="i1">item 1</td></tr>
       <tr><td align="right" port="i2">item 2</td></tr>
       <tr><td align="right" port="i3">item 3</td></tr>
       <tr><td align="right" port="i4">item 4</td></tr>
       <tr><td align="right" port="i5">item 5</td></tr>
       </table>>]
     key2 [label=<<table border="0" cellpadding="2" cellspacing="0" cellborder="0">
       <tr><td port="i1" bgcolor='greenyellow'>&nbsp;</td></tr>
       <tr><td port="i2">&nbsp;</td></tr>
       <tr><td port="i3">&nbsp;</td></tr>
       <tr><td port="i4">&nbsp;</td></tr>
       <tr><td port="i5">&nbsp;</td></tr>
       </table>>]
     key:i1:e -> key2:i1:w [color=red]
     key:i2:e -> key2:i2:w [color=gray]
     key:i3:e -> key2:i3:w [color=peachpuff3]
     key:i4:e -> key2:i4:w [color=turquoise4, style=dotted]
     key:i5:e -> key2:i5:w [color=red, style=dotted]
   }
       }
@enduml



@startuml
digraph G {
graph [label="Problem Frame\nmapping editor\n",labelloc=t,fontsize=18,compound=true];
node[shape = record,fontsize = 10];
edge[arrowtail=none,arrowhead=none,arrowsize=0.8,color=ivory4,fontsize=8];

subgraph "cluster0" {
graph [label = "Model Fragment"];
A01 [label = "{Domain|class::marking\lisTemplate::boolean default false\lname::name\ltype::domain type\l}"];
A02 [label = "{Requirement|isTemplate::boolean default false\lname::name\l}"];
A03 [label = "{Requirement Reference\n\<\<associative\>\>|content::name\lis template::boolean default false\ltype::requirement reference type\l}",shape=Mrecord,style=dotted];
A04 [label = "{Shared Phenomena Set\n\<\<associative\>\>|content::name\lis template::boolean default false\ltype::phenomena type\l}",shape=Mrecord,style=dotted];

/* 1:1-0:M */
edge[dir=both,arrowhead=crowodot,arrowtail=none];
A01 -> A03 [style=dashed];
A01 -> A04 [style = dashed];
A01 -> A04 [style = dashed];
A02 -> A03 [style = dashed];
}

subgraph "cluster1" {
graph [label = "\>\>\>",fontsize = 24];
B01 [label = "{Domain}"];
B02 [label = "{Requirement}"];
B03 [label = "{Requirement\nReference\n}",shape=Mrecord,style=dotted];
B04 [label = "{Shared\nPhenomena\nSet\n}",shape=Mrecord,style=dotted];
F01 [label = "{C0001|if \[-\> controls -\> describes.isTemplate\]\l}"];
F02 [label = "{C0002|if not \[-\> controls -\> describes.isTemplate\]\l}"];
F03 [label = "{C0003|if \[-\> controls -\> describes.type = designed\]\l}"];
F04 [label = "{C0004|if \[-\> controls -\> describes.type = given\]\l}"];
F05 [label = "{C0005|if \[-\> controls -\> describes.type = machine\]\l}"];
F06 [label = "{C0006|if \[-\> controls -\> describes.marking = biddable\]\l}"];
F07 [label = "{C0007|if \[-\> controls -\> describes.marking = causal\]\l}"];
F08 [label = "{C0008|if \[-\> controls -\> describes.marking = lexical\]\l}"];
F09 [label = "{C0009|if \[-\> controls -\> describes.marking = null\]\l}"];
F10 [label = "{C0010|if \[-\> controls -\> describes.isTemplate\]\l}"];
F11 [label = "{C0011|if not \[-\> controls -\> describes.isTemplate\]\l}"];
F12 [label = "{C0012|if \[-\> controls -\> describes.isTemplate\]\l}"];
F13 [label = "{C0013|if not \[-\> controls -\> describes.isTemplate\]\l}"];
F14 [label = "{C0014|if \[-\> controls -\> describes.type = non-constraining\]\l}"];
F15 [label = "{C0015|if not \[-\> controls -\> describes.type = constraining\]\l}"];
F16 [label = "{C0016|if \[-\> controls -\> describes.isTemplate\]\l}"];
F17 [label = "{C0017|if not \[-\> controls -\> describes.isTemplate\]\l}"];
F18 [label = "{C0018|if \[-\> controls -\> describes.type = causal\]\l}"];
F19 [label = "{C0019|if \[-\> controls -\> describes.type = event\]\l}"];
F20 [label = "{C0020|if \[-\> controls -\> describes.type = symbolic\]\l}"];

edge [style = solid];
B01 -> F01 -> F02 -> F03 -> F04 -> F05 -> F06 -> F07 -> F08 -> F09;
B02 -> F10 -> F11;
B03 -> F12 -> F13 -> F14 -> F15;
B04 -> F16 -> F17 -> F18 -> F19 -> F20;

edge [style = invis];
B01 -> B02 -> B03 -> B04;
}

subgraph "cluster2" {
graph [label = "\<\<\<",fontsize = 24];
C01 [label = "{Edge|name := Constraining Reference\larrowtail := normal\ldir := both\lpermitted node1 := domain icon\lpermitted node2 := requirement icon\lstyle := dotted\l}"];
D02 [label = "{Attribute|name::oName\lvalue::-\> describes\l-\> described by.content\l}"];
C02 [label = "{Diagram|name := Frame Diagram\l}"];
C03 [label = "{Node|name := Domain Icon\lcolor = gray\lfillcolor = gold\lfontsize := 12\llabel := describes.preLabel\l + oName + describes.postLabel\lshape := Mrecord\lstyle := filled\l}"];
D03 [label = "{Attribute|name::oClass\lvalue :=-\> describes\l-\> described by.class\l}"];
D04 [label = "{Attribute|name::oName\lvalue := -\> describes\l-\> described by.name\l}"];
D05 [label = "{Attribute|name::postlabel\lvalue := \}\"\l}"];
D06 [label = "{Attribute|name::postlabel\lvalue := \|\{\|b\}\}\"\l}"];
D07 [label = "{Attribute|name::postlabel\lvalue := \|\{\|c\}\}\"\l}"];
D08 [label = "{Attribute|name::postlabel\lvalue := \|\{\|x\}\}\"\l}"];
D09 [label = "{Attribute|name::prelabel\lvalue := \"\{\|\l}"];
D10 [label = "{Attribute|name::prelabel\lvalue := \"\{\l}"];
D11 [label = "{Attribute|name::prelabel\lvalue := \"\{\|\|\l}"];
D12 [label = "{Attribute|name::oType\lvalue := -\> describes \l-\> described by.type\l}"];
C04 [label = "{Holding Box|name := Domain Template\lcolor := slategray\lfillcolor := white\lfontcolor := slategray\lfontsize := 9\llabel := oName\lreadonly := true\l}"];
D13 [label = "{Attribute|name::oName\lvalue := -\> describes \l-\> described by.name\l}"];
C05 [label = "{Edge|name := Edge Template\lcolor := white\llabel = oName\lstyle := invis\l}"];
D14 [label = "{Attribute|name::oName\lvalue := -\> describes \l-\> described by.contents\l}"];
C06 [label = "{Node|name := Phenomena\l}"];
D15 [label = "{Attribute|name::oName\lvalue::-\> describes\l\-\> described by.contents\l}"];
C07 [label = "{Edge|name := Reference\l}"];
D16 [label = "{Attribute|name::oName\lvalue := -\> describes \l-\> described by.contents\l}"];
C08 [label = "{Node|name := Requirement Icon\l}"];
D17 [label = "{Attribute|name::oName\lvalue := -\> describes \l-\> described by.name\l}"];
C09 [label = "{Edge|name := Shared Phenomena\l}"];
D18 [label = "{Attribute|name::oName\lvalue := -\> describes \l-\> described by.contents\l}"];
D19 [label = "{Attribute|name::oType\lvalue := C\l}"];
D20 [label = "{Attribute|name::oType\lvalue := E\l}"];
D21 [label = "{Attribute|name::oType\lvalue := Y\l}"];

C01 -> D02;
C03 -> D03 -> D04 -> D05 -> D06 -> D07 -> D08 -> D09 -> D10 -> D11 -> D12;
C04 -> D13;
C05 -> D14;
C06 -> D15;
C07 -> D16;
C08 -> D17;
C09 -> D18 -> D19 -> D20 -> D21;

edge[style="invis"];
C01 -> C02 -> C03 -> C04 -> C05 -> C06 -> C07 -> C08 -> C09;
}

subgraph "cluster5" {
graph [label = "Editor Elements"];
E01 [label = "{Node\n|color::color\lfillcolor::fillcolor\lfontname::font\lfontsize::fontsize\llabel::name\lname::name\lreadonly::boolean default false\lshape::shape\lstyle::style\l}"];
E02 [label = "{Edge\n|arrowtail::edge end\ldir::dir\lname::name\lpermitted node1::name\lpermitted node2::name\lstyle::style\l}"];
E03 [label = "{Attribute\n|name::name\lvalue::text\l}"];
E04 [label = "{Diagram\n|defaults::attributes\ledge defaults::attributes\lname::name\lnode attributes::attributes\l}"];
E05 [label = "{Holding Box|color::color\lfillcolor::fillcolor\lfontname::font\lfontsize::fontsize\llabel::name\lname::name\lreadonly::boolean default false\lshape::shape\lstyle::style\l}"];

/* 0:1-N:M */
E01 -> E02 [arrowhead = crowodot, label = "links", taillabel = " 2:2"];

/* 1:1-0:M  */
edge[dir=both,arrowtail=none,arrowhead=crowodot];
E04 -> E01 [label = nodes];
E04 -> E02 [label = edges];
E04 -> E05 [label = "holding boxes"];

/* 0:1-0:M  */
edge[dir=both,arrowtail=odot,arrowhead=crowodot];
E05 -> E01 [label = "contained nodes"];
E05 -> E02 [label = "contained edges"];
E05 -> E05 [label = contains];

/* 0:1-0:M  */
edge[dir=both,arrowtail=odot,arrowhead=crowodot];
E01 -> E03 [label = characteristics];
E02 -> E03 [label = parameters];
E04 -> E03 [label = attributes];
E04 -> E03 [label = attributes];
E04 -> E03 [label = attributes];
}

{rank = min B01 C01}

edge[style="solid"];
F01 -> C04 [ltail = cluster1];
F02 -> C03 [ltail = cluster1];
F03 -> D09 [ltail = cluster1];
F04 -> D10 [ltail = cluster1];
F05 -> D11 [ltail = cluster1];
F06 -> D06 [ltail = cluster1];
F07 -> D07 [ltail = cluster1];
F08 -> D08 [ltail = cluster1];
F09 -> D05 [ltail = cluster1];
F10 -> C04 [ltail = cluster1];
F11 -> C06 [ltail = cluster1];
F11 -> C08 [ltail = cluster1];
F12 -> C05 [ltail = cluster1];
F14 -> C07 [ltail = cluster1];
F15 -> C01 [ltail = cluster1];
F16 -> C05 [ltail = cluster1];
F17 -> C06 [ltail = cluster1];
F17 -> C09 [ltail = cluster1];
F18 -> D19 [ltail = cluster1];
F19 -> D20 [ltail = cluster1];
F20 -> D21 [ltail = cluster1];
       }
@enduml

@startuml
digraph G {
size = "8.5,11";
label = "";
rankdir=LR;
bgcolor = "transparent";
center = 1;
rank = same;
margin = 0;
orientation = Portrait;
0 [label = "0", shape = doublecircle, style = bold, fontsize = 14, color="#339933"]
    0 -> 0 [label = "a", fontsize = 14];
    0 -> 0 [label = "b", fontsize = 14];
    0 -> 0 [label = "cd", fontsize = 14];
    0 -> 0 [label = "efg", fontsize = 14];
    0 -> 0 [label = "a", fontsize = 14];
    0 -> 0 [label = "q", fontsize = 14];
    0 -> 0 [label = "xyzabc", fontsize = 14];
       }
@enduml


@startuml
skinparam rectangle {
    roundCorner<<Concept>> 25
    roundCorner<<Foo>> 45
    backgroundColor<<Concept>> White
}

rectangle "Concept Model" <<Foo>> {
    rectangle "e" <<Concept>> as e
    rectangle "F"
}
@enduml

@startuml
skinparam lifelineStrategy solid
skinparam handwritten false
skinparam monochrome true
skinparam packageStyle rect
skinparam defaultFontName FG Virgil
skinparam shadowing true
skinparam classBorderThickness .5
skinparam usecaseBorderThickness .5
skinparam titleBorderRoundCorner 15
skinparam titleBorderThickness 2
skinparam rectangleBorderThickness 0.5

skinparam classBorderThickness<<stereo>> 5
skinparam packageBorderThickness<<stereo>> 1.5
skinparam packageBorderThickness 0.5
skinparam classFontColor red
skinparam classFontSize 10
skinparam classFontName Courier

participant "__Connection Factories__" as connectionFactories
participant "__Connections__" as Connections
participant "__Session__" as Session
participant "__Message Producer__" as messageProducer
participant "__Message Consumer__" as messageConsumer
participant "__Temporary Destination__" as temporaryDestination
participant "__Broker__" as Broker


/' This is how you can
span multiple lines
of comments
'/
hide footbox
title Connection Factories

connectionFactories -> Connections : createConnections()
activate Connections
Connections -> Session : createSession()
deactivate Connections
activate Session

Session -> messageProducer : CreateProducer()
activate messageProducer
Session -> messageProducer : CreateMessage()
deactivate Session


deactivate messageProducer
Session -> temporaryDestination : createTemporaryQueue() or createTemporaryTopic()
activate temporaryDestination
deactivate temporaryDestination
Session -> messageConsumer : CreateConsumer()
activate messageConsumer
deactivate messageConsumer

Connections -> Connections: start()
activate Connections
deactivate Connections
messageProducer -> Broker : send()
activate Broker
Broker -> temporaryDestination: send()
deactivate Broker
activate temporaryDestination
deactivate temporaryDestination



@enduml
